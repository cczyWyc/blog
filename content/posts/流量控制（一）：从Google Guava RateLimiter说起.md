---
title: "流量控制（一）：从 Google Guava RateLimiter说起"
subtitle: "高并发系统利器：限流"
description: "Google Guava RateLimiter设计，内含源码解析"
date: 2023-04-20
toc: true
author: "cczywyc"
draft: false
tags: ["流量控制", "Java"]
---

# 前言		

​		关于这篇文章起因，最近计划看一下《Effective Java》，然后我了解到此书的作者同样也是Google Guava库的作者，作为一个练习2年的Java的程序员，还没有研究过Guava，属实有点说不过去，借此机会研究了一下Google Guava。

​		先简单说一下[Google Guava](https://en.wikipedia.org/wiki/Google_Guava)库，它不仅仅是JDK的升级库，诸如包含集合（collections）、缓存（caching）、并发库（concurrency libraries）、原生类型支持（primitives support）、字符串处理（string processing）、I/O库等，还是《Effective Java》这本书中那些优秀经验的实践代表，两者应该结合起来阅读学习。在Guava中有两个实现我很感兴趣，一个是它实现的Bloom Filter（布隆过滤器），另外一个就是本篇文章即将介绍的RateLimiter（限流器）。

​		我们平时在开发高并发的分布式系统时，会借助许多手段来满足系统的并发要求，我总结下来大致分为下面几个方面：

* 缓存：通过缓存系统可以减少对底层数据存储系统的频繁访问，从而有效地提高系统的访问能力。从前端的浏览器，到网络，在到后端的服务，底层的数据库、文件系统、硬盘和CPU，全都都有设计缓存，这是提高快速访问能力的有效手段。
* 负载均衡：通过负载均衡可以将请求分摊到多个服务器上，避免单点故障和资源瓶颈，它是水平扩展的关键技术。
* 异步调用：异步调用的一个主要的技术手段就是消息队列，通过消息队列实现异步任务处理、系统解耦、削峰填谷等。
* 流量控制：通过限制系统等请求量和并发量，防止系统过载。常见的流量控制的手段包括限流、熔断和降级。

# 常见的限流实现方式

## 计数器算法

​		这是最基本、最粗暴的算法。一般来说，该算法会会维护一个计数器，当处理请求时，就对计数器做加一操作，当你请求处理完时，就对计数器做减一操作，如果计数器达到某个数量（预先设定的阀值），则按照限流的规则处理，防止系统过载。

## 采用队列的算法

​		这个算法有点像FIFO，请求有快有慢，所有的请求都放入队列中，消费端以固定的速率从消息队列中取出请求消费，从而控制整个系统的处理流量，以下就是这个算法的示意图：

![](https://static001.geekbang.org/resource/image/c8/3d/c8f774f88ab8a4b72378971263c0393d.png?wh=860*175)

当然，我们可以在上面这个算法的基础上，延伸出其他更为高阶的用法，例如利用优先级队列实现一个具有优先级的流量控制算法。例如针对不同的请求，处理时先处理优先级高的队列，等优先级高的队列处理完了再处理优先级低的队列；再比如，还可以设置不同的权重，根据队列的权重处理来先后处理不同的请求。

## 漏桶算法

​		关于漏桶，wikipedia上有关于它的[词条](https://en.wikipedia.org/wiki/Leaky_bucket)。
